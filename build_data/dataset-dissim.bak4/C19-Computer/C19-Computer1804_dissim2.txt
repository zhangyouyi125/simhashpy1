微型机与应用
MICROCOMPUTER & ITS APPLICATIONS
2000　No.19　No.1　P.15-17




用VB的定时器控件产生精确的定时
董静薇　李欣
摘 要： 分析Timer控件的2个重要属性及用Timer控件产生定时器事件的定时精度，根据应用程序对定时的要求提出2种用Timer控件产生精确定时的方法。 
关键词： Timer控件 定时精度 时间校准
　　在工业控制中有许多需要定时完成的操作，如：定时显示当前时间，定时刷新屏幕上的进度条，上位机定时向下位机发送命令和传送数据等。Visual Basic语言提供了定时器控件Timer来完成定时中断的功能，对其编程后可在一定的时间间隔执行某些操作。但由Timer控件的Interval属性（定时间隔属性）确定的定时时间精度很低，不超过1／18s，这对于很多要求精确定时的控制系统来说是远远不够的。
　　2．在1个简单的立方体上放映一段电影。
1 Visual Basic的Timer控件
　　Timer控件响应时间的流逝，它独立于用户，在相等的时间间隔不断接受定时器事件，产生定时器中断。每个Timer控件必须要与窗体关联，因此要创建定时器应用程序就必须至少创建1个窗体，此窗体若不需要完成其它操作，就可以使窗体不可见。Timer控件在设计时出现在窗体上，所以可以选定这个控件，查看属性，编写事件过程。
　　在驱动插值器过程中，由TimeSensor节点随时间的流逝产生0～1之间递增的SFFloat值，每产生1个值，经过路由，OrientationInterpolator节点接收这个值，并把它的值与关键码进行匹配，一旦匹配成功，则对应于这个关键码（key）的关键码值（keyValue）被发送出去，如果这个值处于2个相邻的关键码之间，则产生1个在与2个关键码相对应的关键码值之间进行插值的事件，得到的关键码值又通过第2条路由，使Transform节点接收到这个值，从而改变立体的位置。Timer控件有2个与定时功能有关的重要属性。
1.1 Enabled属性
　　定时器的Enabled属性不同于其它对象的Enabled属性。
　　1．完整的“T”形立体旋转落下的动画代码。在定时器已经启动的情况下改变定时间隔属性后，再次将Enabled属性设为True则会停止现定时过程，立即重新以新的设置开始定时。
1.2 Interval属性
　　Interval属性指定定时间隔，即每次产生定时器事件之间的毫秒数。间隔的长度取决于定时要求，因为存在某些内部错误的可能性，常将间隔设为定时的一半。它的取值在0～64，767之间（包括这2个数值），即用Timer控件产生的最长定时时间约为64.8s。若设置Interval属性为0，则相当于关闭定时器。如果应用程序正在进行对系统要求很高的操作，例如长循环高强度的运算或正在访问驱动器、网络或端口，则应用程序定时器事件的间隔可能比Interval属性指定的间隔长。
　　由于系统每秒生成18个时钟信号，所以即使Interval属性的单位是ms，定时间隔的实际精度也不会超过1/18s。可见，用Interval属性设置的时间间隔不准确，每次产生定时器事件间隔最大误差能达到55ms，其累积误差将会急剧增大。经实验发现，设置1个Timer控件的Interval属性为200ms，每产生5次定时器事件，将秒计数单元加1作为累计的时间，同时读取系统时钟，即实际时间，则程序运行20min后此累计时间比实际时间要慢大约1min。将Interval属性减小，直至156ms时，实验结果毫无变化。
　　5．使用纹理坐标的动画
　　如果把1幅二维图像包裹在对象上来进行着色，就如同在墙上贴墙纸一样，也能得到很好的效果，这种二维图像叫做纹理。而且随着程序运行时间的增加，其误差也越来越大。可见，要确保时间准确，应在需要时检查系统时钟，而不能在内部追踪积聚的时间。要使用Timer控件在精确的时间间隔内执行某些操作或累计较长的时间，则必须对Timer控件的定时进行校准。例如在1个虚拟房间中放置了1台电视机，当漫游者进入房间时，看见电视机屏幕上正在放映电视或电影，而并非一副静止死板的图像，显然就大大地增强了虚拟世界的逼真程度。
2.1 查询等待法
　　要产生1s的定时，可将1s分成5个部分，每段长度为200ms。当程序在每秒钟的结尾部分（800ms～1s）无其它操作时，可用循环等待的办法使时间在每秒的末尾对齐。设Timer控件的Interval属性为200ms，则在产生4次定时器事件后（此时实际时间已大于800ms），不再等待第5次定时器事件，而是反复查询当前系统时钟。当系统时钟的秒数加1后，即表示下1s开始，此时重新启动定时器控件，使它开始新一轮的定时。
　　＃VRML V2．0 utf8
　　DEF T Transform｛
　　center 0－2 0
　　children [
　　　　Shape｛
　　　　　　geometry Box ｛size 1 4 1 ｝
　　　　　　appearance Appearance｛
　　　　　　　　material Material｛
　　　　　　　　　　diffuseColor 1 0 0
　　　　　　　｝
　　　　　　 ｝
　　　　｝
　　　　Transform｛
　　　　　　translation 0 2 0
　　　　　　children [
　　　　　　　　Shape｛
　　　　　　　　　　geometry Box ｛size 3 1 1｝
　　　　　　　　　　appearance Appearance ｛
　　　　　　　　　　　　material Material ｛
　　　　　　　　　　　　　　diffuseColor 1 0 0
　　　　　　　　　　　｝
　　　　　　　　　 ｝
　　　　　　　 ｝
　　　　　]
　　　｝
　　]
　　｝
　　DEF P OrientationInterpolator｛
　　key [0，0．5，0．8 1]
　　keyValue [0 1 0 0，0 1 0 1.57 0.577 0.577－0.577 2.07，0.577 0.577 －0.577 2.07]
　　DEF TS TimeSensor
　　stopTime －1
　　loop TRUE
　　cycleInterval 5
　　｝
　　ROUTE TS．fraction_changed TO P．set_
　　ROUTE P．value_changed TO T．set_rotation
　　本例中，立体从位置0 1 0 0开始启动，当时间达到一半的时候（0．5），立体完成绕Y轴逆时针90°旋转（0 1 0 1．57），当时间达到0．8处的时候，立体完成绕Z轴顺时针90°旋转（0．577 0．577 －0．577 2．07），然后稳定到时间满（1），其中整个过程所用时间由TimeSensor节点中的cycleInterval的值来控制，本例中整个旋转倒下过程耗时为5s。需要指出的是，用这种方法校准时在第一次启动Timer控件前也要反复查询系统时钟，使它在某1秒刚开始时立即启动。
　　在程序1中，t1表示用Timer控件定时累加并校准后的秒值。（在实现中所举例子读者可以在机器上自己实验，可用如Microsoft的WordPad编辑器创建VRML文件，文件必须以．wrl作为扩展名，只要所用浏览器Netscape Navigator或Internet Explorer安装了VRML的插件，双击自己的文件，就能显示出所构造的虚拟现实环境）。这2个版本最大的不同在于，VRML 1．0没有包括高级交互和动画性能，因此它展现的仍然是一个静态的世界，而VRML2．0在这方面获得了重大突破，它把目前为止的各项多媒体技术融合进去，使构造出的三维虚拟世界具有声音、动画、人机交互等功能，从而使计算机生动逼真地模拟了真实的世界。经上述实验可知：5次200ms定时比实际1s的时间要长，而5次150ms定时比实际1s时间要短。那么可以在每产生5次定时器事件时读一次系统时钟，得到当前的秒值，再与累加计数得到的秒值比较。若累加值偏小则表明累加时间慢了，将Timer控件的Interval属性设为150ms，重新启动定时器；若累加值偏大，则恢复Interval属性为200ms。
　　这种方法的特点是：不是每1秒钟都十分精确，但却消除了累积的时间误差，无论程序运行多少时间定时误差均为正负1s。与第一种方法比较，动态校正法的优点是没有循环等待的时间，从而不占用系统更多的资源。
　　在程序2中，TimerCount为定时200ms计数器，取值范围0～5。要达到预期动画效果，需要第一幅图像感知到用户鼠标的点击动作，然后在一定时间内逐个切换角色，直到最后一幅图像，这样用户就能在屏幕上看到怪物中枪死去的整个动画。
程序2：
Dim TimerCount As Integer
Dim Clock01 As Integer
Private Sub Form_Load（）
Form1．Timer1．Interval＝200　　′先设定时时间间隔为200ms
TimerCount＝0　　　　′定时200ms计数器清零
Clock01＝CInt（Mid（Time，7，2））　　　′取当前时间的秒值
Form1．Timer1．Enabled＝True　　　′启动定时器控件
End Sub
Private Sub Timer1_Timer（）
Dim Click02 As Integer
TimerCount＝TimerCount＋1　　　　′定时200ms计数器加1
If TimerCount＝5 Then　　　　　′定时1s时间到
　　Clock02＝CInt（Mid（Time，7，2））　　′取当前时间的秒值
　　Clock01＝（Clock01＋1）Mod 60　　′定时累加得到的秒值
　　If Clock01＞1 And Clock02＞1 Then　　′为防止59加
　　　　′1跳变到0时出现错误，秒值为0和1时不做处理
　　　　If Clock02＞（Clock01＋1）Mod 60
Then
　　　　　　Form1．Timer1．Interval＝150　　　′累加值偏小，缩短定时时间间隔
　　　　　　Form1．Timer1．Enabled＝True　　　′重新启动定时器控件
　　　　Else
　　　　　　If Clock01＞（Clock02＋1）Mod 60
Then
　　　　　　　Form1．Timer1．Interval＝200　　′累加值偏大，增大定时时间间隔
　　　　　　　Form1．Timer1．Enabled＝True　　′重新启动定时器控件
　　　　　　End If
　　　　End If
　　End If
　　TimerCount＝0　　′定时200ms计数器清零
End If
End Sub
　　程序运行后，Click01是经过动态校正的秒值，可以用它在内部追踪累积时间或用来执行一些需要与下位机同步进行的操作。
张宁（成都电子科技大学微型机研究所610054）
袁宏春（成都电子科技大学微型机研究所610054）
收稿日期：1999－07－06
