微型机与应用
MICROCOMPUTER & ITS APPLICATIONS
2000　No.19　No.1　P.15-17




用VB的定时器控件产生精确的定时
董静薇　李欣
摘 要： 分析Timer控件的2个重要属性及用Timer控件产生定时器事件的定时精度，根据应用程序对定时的要求提出2种用Timer控件产生精确定时的方法。但在二事件过程（cmdStart_Click（）/cmdStorp_Click（））与其对应的通用过程（procStart/procStop（））间仍以参数的形式传递“开始时间”，防止在通用过程中直接使用Form级公用变量。Visual Basic语言提供了定时器控件Timer来完成定时中断的功能，对其编程后可在一定的时间间隔执行某些操作。但由Timer控件的Interval属性（定时间隔属性）确定的定时时间精度很低，不超过1／18s，这对于很多要求精确定时的控制系统来说是远远不够的。本文在详细讨论Timer控件的特点与局限性之后，针对不同情况下精确定时的要求，提出2种用Timer控件产生精确定时的方法。
1 Visual Basic的Timer控件
　　Timer控件响应时间的流逝，它独立于用户，在相等的时间间隔不断接受定时器事件，产生定时器中断。每个Timer控件必须要与窗体关联，因此要创建定时器应用程序就必须至少创建1个窗体，此窗体若不需要完成其它操作，就可以使窗体不可见。Timer控件在设计时出现在窗体上，所以可以选定这个控件，查看属性，编写事件过程。在程序运行时定时器控件不可见，所以其位置和大小无关紧要。Timer控件有2个与定时功能有关的重要属性。
1.1 Enabled属性
　　定时器的Enabled属性不同于其它对象的Enabled属性。对于大多数对象，Enabled属性决定对象是否响应用户触发的事件；对于Timer控件，将Enabled属性设为True和False时会启动和停止定时器操作。在定时器已经启动的情况下改变定时间隔属性后，再次将Enabled属性设为True则会停止现定时过程，立即重新以新的设置开始定时。
1.2 Interval属性
　　Interval属性指定定时间隔，即每次产生定时器事件之间的毫秒数。间隔的长度取决于定时要求，因为存在某些内部错误的可能性，常将间隔设为定时的一半。它的取值在0～64，767之间（包括这2个数值），即用Timer控件产生的最长定时时间约为64.8s。若设置Interval属性为0，则相当于关闭定时器。如果应用程序正在进行对系统要求很高的操作，例如长循环高强度的运算或正在访问驱动器、网络或端口，则应用程序定时器事件的间隔可能比Interval属性指定的间隔长。
　　由于系统每秒生成18个时钟信号，所以即使Interval属性的单位是ms，定时间隔的实际精度也不会超过1/18s。可见，用Interval属性设置的时间间隔不准确，每次产生定时器事件间隔最大误差能达到55ms，其累积误差将会急剧增大。经实验发现，设置1个Timer控件的Interval属性为200ms，每产生5次定时器事件，将秒计数单元加1作为累计的时间，同时读取系统时钟，即实际时间，则程序运行20min后此累计时间比实际时间要慢大约1min。将Interval属性减小，直至156ms时，实验结果毫无变化。

图1　同一Form中的事件过程间数据传送
　　由于Form级私有变量只在说明它的模块中可用（1个Form、标准模块或类模块），所以对可维护性的影响要小一些（相对于全局变量），同时也解决了图1所示的应用中事件过程间数据传送问题。而且随着程序运行时间的增加，其误差也越来越大。将Form1中的全局变量说明为Form级私有变量，增加全局通用过程getStartTime，在Form2中可以调用过程getStartTime读取mStartTime的值，这样就防止了在Form1以外的过程修改mStartTime的值。要使用Timer控件在精确的时间间隔内执行某些操作或累计较长的时间，则必须对Timer控件的定时进行校准。
2 时间校准方法
　　根据应用程序所需要的精确定时的不同情况，下面以产生1s的精确时间为例介绍2种时间校准的方法。事件过程cmdStopClick（）是用鼠标点触命令按钮cmdStop事件的处理程序，表示1个事务活动的结束。
  本来，在过程间传送数据应利用过程的参数来实现，然而，没有办法通过参数将数据从一个事件过程传送到另一个事件过程，较好的办法是使用Form级的私有变量，应尽量避免使用全局变量及Form级共用变量；如果1个变量只在1个Form中修改，而在其它Form中是只读性引用，则可使用1个Form级私有变量和1个全局过程来替代使用全局变量或以Form名称为前缀的Form级共用变量。设Timer控件的Interval属性为200ms，则在产生4次定时器事件后（此时实际时间已大于800ms），不再等待第5次定时器事件，而是反复查询当前系统时钟。当系统时钟的秒数加1后，即表示下1s开始，此时重新启动定时器控件，使它开始新一轮的定时。这种方法的优点是简单明了，且每秒都非常准确。同样，在E－DP编程环境下使用全局变量，对于变量这一因素来说，将最大限度降低程序的可维护性和过程的复用性。
　　在程序1中，t1表示用Timer控件定时累加并校准后的秒值。程序1运行后，可在窗口中显示系统时钟和用Timer控件定时累加产生的时钟，可以看出二者是完全同步的。
1 关于全局变量
　　在面向过程程序设计方法中，由于全局变量的值能被系统中的任何过程修改，所以全局变量被认为是损害过程独立性的重要因素之一，所以在面向过程程序设计中，一个重要的原则是：尽量避免使用全局变量，而提倡使用参数显式地传给被调用的过程。

图6　在Form间利用标准/代码模块传送数据
5 总 结
　　一般事件过程的复用性都很低，将事件过程中用以共享的一组代码分离成1个通用过程，可用这种间接的方式增加原事件过程的复用性和可维护性，如果一个通用过程由多个模块共享，则该通过过程应该放在标准/代码模块中，而不是放在Form中。那么可以在每产生5次定时器事件时读一次系统时钟，得到当前的秒值，再与累加计数得到的秒值比较。若累加值偏小则表明累加时间慢了，将Timer控件的Interval属性设为150ms，重新启动定时器；若累加值偏大，则恢复Interval属性为200ms。
　　这种方法的特点是：不是每1秒钟都十分精确，但却消除了累积的时间误差，无论程序运行多少时间定时误差均为正负1s。
　　对图2所示的通用过程procStart和procStop进行改进，即在其中不直接使用模块级私有变量，而是通过参数传递mStartTime的值，这种改进的版本如图3所示。用鼠标点触命令按钮cmdStart的时间存放在变量mStartTime中，在事件过程cmdStopClick（）中要利用StartTime计算由按钮cmdStart启动的事务活动所用的时间；然而没有办法将mStartTime的值通过参数传递给事件过程cmdStopClick（）（因为事件过程的参数是由系统固定的），因此，在这个应用中，说明了Form级私有变量mStartTime，使得这个容器中的所有过程都可以直接引用或修改mStartTime。Clock01为秒的累加值，取值范围为0～59。
程序2：
Dim TimerCount As Integer
Dim Clock01 As Integer
Private Sub Form_Load（）
Form1．Timer1．Interval＝200　　′先设定时时间间隔为200ms
TimerCount＝0　　　　′定时200ms计数器清零
Clock01＝CInt（Mid（Time，7，2））　　　′取当前时间的秒值
Form1．Timer1．Enabled＝True　　　′启动定时器控件
End Sub
Private Sub Timer1_Timer（）
Dim Click02 As Integer
TimerCount＝TimerCount＋1　　　　′定时200ms计数器加1
If TimerCount＝5 Then　　　　　′定时1s时间到
　　Clock02＝CInt（Mid（Time，7，2））　　′取当前时间的秒值
　　Clock01＝（Clock01＋1）Mod 60　　′定时累加得到的秒值
　　If Clock01＞1 And Clock02＞1 Then　　′为防止59加
　　　　′1跳变到0时出现错误，秒值为0和1时不做处理
　　　　If Clock02＞（Clock01＋1）Mod 60
Then
　　　　　　Form1．Timer1．Interval＝150　　　′累加值偏小，缩短定时时间间隔
　　　　　　Form1．Timer1．Enabled＝True　　　′重新启动定时器控件
　　　　Else
　　　　　　If Clock01＞（Clock02＋1）Mod 60
Then
　　　　　　　Form1．Timer1．Interval＝200　　′累加值偏大，增大定时时间间隔
　　　　　　　Form1．Timer1．Enabled＝True　　′重新启动定时器控件
　　　　　　End If
　　　　End If
　　End If
　　TimerCount＝0　　′定时200ms计数器清零
End If
End Sub
　　程序运行后，Click01是经过动态校正的秒值，可以用它在内部追踪累积时间或用来执行一些需要与下位机同步进行的操作。
董静薇（哈尔滨理工大学西区140信箱150080）
李欣（哈尔滨理工大学西区140信箱150080）
参考文献
1，Mokelvy M，Martinsen R．Visual Basic 5开发使用手册． 北京：机械工业出版社，1997
收稿日期：1999－06－28
