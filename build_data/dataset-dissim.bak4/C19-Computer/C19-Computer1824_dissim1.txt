微型机与应用
MICROCOMPUTER & ITS APPLICATIONS
2000 Vol.19 No.2 P.7-9




利用定点数进行数值运算
朱丹绯　顾钟文　周春晖
摘 要： 利用80387指令和C＋＋提供的面向对象的特性，构造了定点数类，可以代替浮点数进行数值计算，能有效防止在运算中出现协处理器的浮点异常。
关键词： 定点 浮点 数值计算 80387指令
　　当前，大量的数值计算程序已经用C／C＋＋语言开发，运行于PC机的WIN32环境，然而，在此环境下用浮点数进行运算时可能产生溢出、下溢等异常，使程序退出运行。一般的数值计算程序可以从中知道算法的错误，但对于控制和仿真培训领域，如果控制算法或仿真数学模型运行中出现异常使程序终止运行，就会带来不良后果；而如果用屏蔽异常的方法，当发生溢出时，运算结果由80387设置，在随后的运算中可能产生更严重的异常。为此，本文开发了一种定点数类，用于代替浮点数进行运算，能避免出现上述问题。由于浮点数运算和这个定点数类的实现都依赖80387指令，故下面先对80387作一介绍。
1 80387简介
1．1 浮点数格式
　　在计算机里，用来表示数的位数是有限的，所以计算机不能精确地表示出所有的实数，而只能表示无穷个实数的一个极小的子集。这个子集在一般情况下已经可以解决绝大多数的实际问题，而且丢掉的精度也是微不足道的。实数的表示方法有2种：定点数和浮点数。正由于这一点，XML在电子商务B2B（Business to Business）应用中成为企业和企业之间开放性的数据交换标准。欲获得Delphi 5的更详细信息，可拨打电话01068915794／95／96／97。
　　在3种浮点数中，短型实数和长型实数是IEEE754标准所定义的［2］，而临时型实数是80387内部的格式，无论给出什么样类型的数，在80387内部都将它们转化成临时型实数，由于临时型实数精度高，用这种方法，可以提高运算精度，扩大运算范围。CORBA是由800多个软硬件厂商组成的OMG（Object Management Group）组织所制定的开放的、支持多种操作平台的分布式组件规范。
　　这3种实数分别对应于C语言中的float、double和long double类型。
　　有效数字有时被称为尾数。在80387的实数表示法中，规定任何实数只能用下面的格式表示：
　　1．xxxx×2n（x表示1或0）
表1 80387支持的数据类型［1］
数据类型位有效数字大致范围（十进制）
字的整数164－32768≤X≤32767
短型整数329－2×109≤X≤2×109
长型整数6418－9×1018≤X≤9×1018
压缩十进制（BCD）8018－99..99≤X≤99..99十八位）
短型实数326-7－3．39×1038≤X≤3．39×1038
长型实数6415-16－1.80×10308≤X≤1.80×10308
临时型实数8019－1.19×104932≤X≤1.19×104932
表2 浮点数格式[1]
数据类型总位数符号位指数字段有效数字段
短型实数321823
长型实数6411152
临时型实数8011564
表3 80387的异常
代码状态位屏蔽位条件
I，ISIEIM无效操作
DDEDM微小数
ZZEZM被零除
OOEOM溢出
UUEUM下溢
PPEPM精度
　　在二进制小数的左边，有且仅有1位1，于是有尾数规则：在实数的表示中省下这个“1”，节约的1位可以用来提高精度。但是，临时型实数没有隐藏位，1个格式化的临时型实数中第63位永远为1。另外，在任何一种实数表示中，零的偏移指数和有效数字都为0，所以可以从临时型实数的第63位来判断实数是否为零。MIDAS同时支持CORBAIIOP、DCOM、DCERPC以及TCP／IP等多种连接方式。
14 Borland Translation Suite开发国际化应用系统
　　Delphi 5 Enterprise内建的Borland Translation Suite帮助用户开发适应国际化需求、能够在不同语种的Windows环境下执行的应用系统，Borland Translation Suite包含多种便利工具，用于管理可重用、已经翻译过的文字内容，并帮助Delphi界面、Windows资源（Windows Resource）内容的翻译工作。由于定点数本质是整数，不存在下溢的情况，对于溢出，可以在程序中用限幅来解决，在控制和仿真培训软件中，这种限幅一般是合理的，不会对计算产生坏的影响。所以用定点数计算就可能避免一切浮点异常。 
2 定点数的实现
　　高效定点数实现方法需要处理器的直接支持，由于80386支持的最大整数为32位，用32位整数作定点数显然精度太低，所以至少要用80387支持的64位整数。用64位整数，以高双字来表示整数部分，低双字表示小数部分，用来做控制和仿真运算，精度基本能达到要求。在Borland C＋＋5．02版本以上提供了＿int64关键字，于是可以在定点数类中直接声明1个64位整数变量i64，考虑到编程的方便，另设1个结构i32，包含2个32位整数，再将此结构与i64作联合，这样做的另一个目的是方便调试，因为如果在调试中只看到变量i64的值，很难知道定点数对应的实数应该是多少，而如果能分别看到定点数的整数和小数部分，就能知道对应实数大致的值。定点数的完整定义如下：
class fixed
｛
　 public：
　　　　 union
　　　　｛
　　　　　 ＿int64 i64；
　　　　　　　 structunsigned long low；long high；i32；
　　　　　｝；
　　　　　 ＿fastcall fixed　（）｛i64＝0；｝
　　　　　 ＿fastcall fixed（const fixed ＆f）｛i64＝f．i64；｝
　　　　　 ＿fastcall fixed（long h，unsigned long 1＝0）｛i32．
　　　　　　　　　　　　　　　　　　　　　　 high＝h；i32．low＝1；｝
　　　　 ＿fastcall fixed（long double）；
　　　　　 ＿fastcall operator long double（）const；
　　　　　 fixed ＆＿fastcall operator＝（long double ld）｛fixed 
　　　　　　　　　　　　　　tmp（ld）；i64＝tmp．i64；return *this；｝
　　　　　 fixed＿fastcall operator＋（）const｛return *this；｝
　　　　 fixed＿fastcall operator－（）const｛fixed tmp（*this）；
　　　　　　　　　　　　　　　　　　 tmp．i64＝－i64；return tmp；｝
　　　　　 fixed ＆＿fastcall operator ＋＝（const fixed ＆ f）
　　　　　　　　　　　　　　　　　　　｛i64＋＝f．i64；return *this；｝
　　　　 fixed ＆＿fastcall operator*＝（const fixed ＆ f）
　　　　　　　　　　　　　　　　　　　｛i64－＝f．i64；return *this；｝
　　　　　 fixed ＆＿fastcall operator*＝（const fixed ＆）；
　　　　　 fixed ＆＿fastcall operator ／＝（const fixed ＆）；
　　　　　 fixed＿fastcall operator＋（const fixed ＆ f）const
　　　　　　　 ｛fixed tmp（*this）；tmp．i64＝i64＋f．i64；return
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 tmp；｝ 
　　　　　fixed＿fastcall operator －（const fixed ＆ f）const
　　　　　　　 ｛fixed tmp（*this）；tmp．i64＝i64－f．i64；return
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 tmp；｝


　　在数值运算程序的开发中，希望定点数与浮点数的使用方法完全相同，所以在类中定义了这些运算符重载的成员函数，保证了使用2种数的C代码的一致性。对这些成员函数的实现来说，最大问题是效率，用了定点数后效率大大下降是不能容许的。解决的方法是大量采用inline函数，这种函数的代码直接插入程序，没有调用过程，效率很高，对不能用inline函数实现的成员函数，采用＿fastcall关键字来加快调用进程。这类函数只有4个：定点数和浮点数相互转换的2个函数以及“*＝”、“／＝”这2个运算符重载函数。
　　对于定点数和浮点数相互转换的2个函数，本文在3种浮点数中选择long double，即80387中的临时型实数来做相互转换，这样选择的理由是：
　　1．临时型实数的精度最高，不会因转换而丢失精度。delphi 5 Enterprise版能帮助企业开发电子商务应用系统，在公元2000年后保持强大的竞争优势并掌握市场先机。
　　3．临时型实数没有隐藏1，可以方便地判断1个数是否为0。
　　从实现上说，这2个函数的实质是在做浮点数和整数的转换，只不过指数部分差了32位，由此，可以利用80387中的浮点数和整数转换的指令。新版本的MIDAS DataBroker使用无状态Stateless设计思想，以更好地配合Microsoft Transaction Server适应低带宽环境下的多级分布式应用。在这中间要考虑实数为零的情况，因为零的指数必为0，若指数加了32，就成了伪零［1］，是80387所不支持的，会引起操作异常。对fixed类型转化为long double类型的函数，实现方法与此类似，不再赘述。BusinessInsight技术完全使用Delphi纯VCL组件组成。对于运算符／＝的重载函数，实现方法也与此相似。
　　实际测试中，乘法的速度为80387指令的1／5，加法的速度为80387指令的1．5倍，效率能令人满意。TeeChart 4．0版应用图表组件，让文字资料转化为可视化信息。MIDAS多级应用完全遵循业界标准分布式组件规范CORBA、COM、MTS，不参杂任何专有的解决方案