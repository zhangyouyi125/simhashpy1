计算机应用
COMPUTER APPLICATIONS
1999年 第19卷 第6期 Vol.19 No.6 1999



多线程应用程序的同步技术
冯美霞
　　摘　要　本文描述了写一个多线程应用程序时，如何控制对全局变量和共享资源的访问。特别是在大量的读写操作且读／写比很大的情况下，如何通过使用复合同步对象使程序性能得到很大提高。管理信息的交换是通过 SNMP 协议数据单元 (PDU) 完成的，在 SNMP 协议中，有 5 种基本的 PDU ，它们是： Getrequest-PDU ， Getnextrequest-PDU ， Getresponse-PDU ， Setrequest-PDU ， Trap-PDU 。任何发往该号码的分组将被发往列表上的所有成员；②当一个分组到达 SMDS 网络时，路由器先确定源地址是否与输入线一致，如果不一致，分组被抛弃；而且 SMDS 提供地址屏蔽，因此用户可以有效地建立私有网络，与外界没有 SMDS 联系，确保了网络的安全性。由于用户使用网络的方式不同，其数据的采集方法也不相同，而用户本身又可分两类：个人用户和集团用户 ( 如学校等 ) ，对他们的计费方式都有所区别。因为在软件中的每个线程都有对全局变量，函数内部静态变量，以及其它一些进程相关的资源如文件句柄等的相同的访问权。 
　　网络建设应从业务需求出发，把握住网络的发展方向，采用最先进的软、硬件产品和组网技术，以确保所建的系统能满足银川海关业务要求， 适应海关行业自身发展的特点和网络通信技术的更新换代，能在投资的基础上过渡到下一代产品和新技术体制，不致于造成经济和时间的巨大浪费。解决的办法，是通过对线程的非对称使用，那就是分给每个线程特定的、不同的任务，从而把对特定进程资源的访问限制在单个线程内。
　　Win32 API提供了许多灵活的同步对象，它们可以使程序能管理对在同一个或不同的进程中的线程之间共享的数据和资源的访问。使用Win32同步对象的优点就是可以不通过串行化线程来控制对资源的访问。但如果同步做得不仔细，性能将因为线程的串行化而下降：它们将被阻塞或不必要的长期等待对共享资源的访问。 
　　此外，还有一些对用户不可见的函数集中在 Server 方，主要的两个函数是：为注册服务的 RegisteredProc() 和为 Client 端远程过程调用服务的 CallProc() 。
2　使用Win32同步对象技术
2.1　统一的方法：Mutexes
　　最简单也是最好的控制访问共享资源的方法就是使用单个的Mutex。在这里,用单个的Mutex来表示Win32 Mutex对象和Win32关键段对象，因为它们服务于相似的目的。究竟使用那一个取决于你的程序：关键段对象速度快且占用的系统资源少，但是它只工作于一个指定的进程并且不支持超时机制。于是,当你想控制程序的所有代码时最好让它们在单个进程中。 
3 网络操作系统及软件平台 
3.1 网络操作系统 
　　选择了 Microsoft 的“ Windows NT ”作为网络管理软件。对每一个或一组共享的资源分配一个不同的Mutex，看起来似乎是更好的办法，但它面临如何避免死锁这个问题。一个经典的死锁例子是：一个线程拥有Mutex A，然后被阻塞，以等待Mutex B，然而另一个线程拥有Mutex B，然后被阻塞，以等待Mutex A。
　　尽管这种情况似乎不可能发生，但在一个模块化程序中完全有可能。G为一聚集函数。不幸的是，这需要你将内部的具体实现暴露给其它的模块。利用这一特点，把需要及时处理的任务放到消息循环中，就可以使网络消息得到最大可能的及时处理。因此，通常最简单的办法就是只用一个Mutex，并且避免在使用Mutex时进行耗时的操作以使串行化程度最小。
2.2　SYNCHRO类
　　一个提供同步功能的C++类。如果要对多个表进行操作，则需要为每个表建立一个数据管道。同时，提供一个一致的界面，便可不必修改程序，就可以演示多个不同的复合同步对象。 Socket 首先是由 4BSD Unix 提出，它采用 Client/Server 模式的通信机制，解决了网络之间连接和数据通信问题?
BOOL Lock(SYNCH―LOCK―TYPE);　　　　　　　　　　　　　　　　　　　// Lock the object
BOOL Unlock(SYNCH―LOCK―TYPE); 　　　　　　　　　　　　　　　　　// Unlock the object
BOOL Promote(void); 　　　　　　　　　　　　// Promote the object from read to write 
};
2.3　相关名词解释
　　同步对象　就是一个句柄可以在对应于多个线程的等待函数中定义。这些短线路可选用各种连接办法：如使用 DQDB 的城域网 (MAN) ，从电话公司租用很短的高速数字专线，采用直接电缆连接，或者建立红外线路等。多个函数可以拥有同一个同步，对象从而使跨进程同步成为可能。
　　Mutex对象　一个Mutex对象就是这样一个同步对象：当它不属于任何一个线程时它的状态是Signaled，反之则处于nonSignaled状态。一个线程在同一时刻只能拥有一个Mutex。
　　事件对象　一个事件对象就是一个可以被SetEvent()或PulseEvent()函数显式设定状态的同步对象。事件对象在通知线程一个特定事件发生时很有用。
　　关键段对象　关键段对象提供类似于Mutex的同步机制。区别在于关键段对象只能被同一个进程中的线程使用。
　　第一个定义是一个称作SYNCH―LOCK―CAPS的枚举类型，其用它能支持的锁的类型来描述它的能力，还有一个SYNCH―LOCK―TYPE枚举类型描述类所能支持的锁的类型。
　　接下来有一个称作GetCaps的函数，它使类的用户知道一个特定的实现具有何种功能。IsValid成员函数确定一个特定的SYNCHRO对象是否有效。最使人感兴趣的是Lock和Unlock函数，它们允许类的用户，按需要的方式声明对对象的访问。线程根据需要和类的支持能力，声明所需要的锁的类型。一经声明后，线程就可以访问共享的数据和资源。结束时，线程释放锁，使其可以被其它线程使用。
　　要注意的是，没有在类中定义任何私有的数据，成员函数也未定义。
3　SYNCHRO类的实现
3.1　SYNCHAPP程序
　　SYNCHAPP是一个用于演示SYNCHRO类的Win32控制台程序。SYNCHAPP是一个随机产生各种同步请求的程序。此外，主站的交换信息还可以存储在服务机的数据库中，由服务机发布到信息网上，使得主站只需面对服务机一个节点，而不是全网的所有节点，这也大大缓解了主站的负担。
　　在讨论SYNCHAPP的实现之前，先介绍它的局限性。那就是它不基于任何一种现实情况。通过调整线程的数目和不同同步请求的比例，可以产生各种“交通”模式。
　　因为SYNCHAPP是一个模拟程序，它并不代表你的实际应用程序。SYNCHAPP中的锁的开关时间间隔比实际应用要长得多。这样做使得SYNCHAPP的输出结果比较短。SYNCHAPP中最令人感兴趣的是SynchroSimulation函数和它的GetAction辅助函数。这样动态监控的通信底层支持已经具备。DisplayStatistics和DisplayStatus函数把模拟的进行情况输出到控制台。
　　每个工作线程运行SynchroSimulation函数，它包含一个无限循环，该循环不定期的休息，并申请SYNCHRO类支持的锁。
3.2　读／写同步
3.2.1　如何合并多个Win32同步对象
　　设想一下如下的情况：你有一个管理用户帐号和密码的数据库。管理员可以增加或删除一个用户，用户能修改密码。但在实际操作中，访问数据库的大部分时间都花在验证请求上，比如这是一个有效帐户？密码正确？
　　显然，如果允许两个线程同时读取数据库，或一个正在读但另一个正在写。由于验证请求并不需要修改数据库，没有理由不让多个验证请求同时发生。如果用单个Mutex，不需要串行化验证请求。只需要一个同步对象，其允许多个线程同时读数据库，或允许单个线程修改数据库，但两者不能同时发生。于是就把这种同步对象称作“多读或单写”同步对象。
　　当提到读方式或写方式访问资源的时候，更精确的提法是共享和独占资源。这种方式的访问已经在很多平台上为I/O实现了。当打开一个文件用于读，禁止写，你就是一个只读者，可以同时读许多个文件；当打开一个文件用于读写，则一旦文件被打开，它就不能被其它用户访问。你并不想把这种方式应用于同步，因为这是一种低效率的资源使用方式。而且它不象通常同步对象那样提供自动阻塞和释放线程的功能。那么你如何构造一个“多读或单写”的同步对象呢？可以把假设的多个同时读，看成是虚拟的单个写，这种模型有点象已经实现的单个Mutex的情况。很可惜，不能在这里使用单个Mutex，因为对Mutex的拥有涉及到一个特定的线程，且只有Mutex的拥有者才能释放它。这对虚拟的单个写不起作用。因为在这种情况中，Mutex的拥有者不能保证是其释放者。
　　步骤：　分配D［0］*D［1］*……*D［j-1］的数组空间M；
//外层循环
for (d［n-1］=0; d［n-1］<D［n-1］; d［n-1］+　+)
　for (d［n-2］=0; d［n-2］<D［n-2］; d［n-2］+　+)
　　……
　　　for (d［j+1］=0; d［j+1］<D［j+1］; d［j+1］+　+)
　　　{ 
　　　　for (d［j-1］=0; d［j-1］<D［j-1］; d［j-1］+　+)
　　　　　……
　　　　　for (d［1］=0; d［1］<D［1］; d［1］+　+)
　　　　　　for (d［0］=0; d［0］<D［0］; d［0］+　+)
　　{依key从小到大的顺序从B-树中读入下一个元组，并加到M［ d［0］］［d［1］］…［d［j-1］］单元中。Win32自动重置事件可以被任何一个线程设置。它一旦被设定，则恰好只有一个等待进程（虚拟写）被释放，然后事件被自动重置。为了完成同步对象，你需要串行化读线程对自动重置事件的访问，让只有一个读线程认为它是最后一个读线程。所以，仅有一个读线程在它读完之后设置自动重置事件。类似的，只有一个读线程认为它是第一个读线程，因此如果第一个读线程被阻塞以等待写线程完成，其它的读线程也一样。
　　hevExclusive事件保证了只允许一个写线程在任一时间通过锁函数。由于hevExclusive是一个自动重置事件，当它被设置时只有一个线程被释放，接着该事件被系统自动的重置。如果该事件恰好抓住了写线程锁，那么其余的读和写线程就都被阻塞了。写线程和第一个读线程被阻塞在hevExclusive，其余的读线程被阻塞在csReader。但是只要没有读线程被阻塞在hevExclusive上，csReader只能被任一线程把持一会儿。图1给出了多个线程试图拥有读／写锁，以及SYNCHRO类中针对“多读或单写”同步对象的实现细节。
写线程1　 读线程1　 读线程2　 写线程2
申请hevExclusive
　　　　　申请cdReader
　　　　　cReaders=1
　　　　　阻塞在hevExclusive
　　　　　　　　　　阻塞在cdReader
　　　　　　　　　　　　　　　阻塞在hevExclusive
释放hevExclusive
　　　　　申请hevExclusive
　　　　　释放cdReader
　　　　　　　　　　申请cdReader
　　　　　　　　　　cReaders=2
　　　　　　　　　　释放cdReader
　　　　　申请cdReader
　　　　　cReaders=1
　　　　　释放cdReader
　　　　　　　　　　申请cdReader
　　　　　　　　　　cReaders=0
　　　　　　　　　　释放hevExclusive
　　　　　　　　　　　　　　　申请hevExclusive
　　　　　释放cdReader
图1　"多读或单写"同步对象的实际运行示例
3.2.2　SYNCHRO类对SYNCHAPP模拟程序的影响
　　SYNCHAPP现在以4:1的比例产生读和写请求。当读／写请求比例加大时，一个“多读或单写”同步对象比一个Mutex同步对象性能好，因为它允许多个读请求同时进行。其要点是引入了前置通信服务机减少了主站的通信负荷，实现了不同网络通信协议的透明调用，扩展了电力部部颁应用层协议，提供了不同应用层协议的主站接入方式。
4　小结
　　当写一个多线程应用程序的时候，控制对全局变量和资源的访问是很必要的。在大多数情况下，单个的Mutex同步对象已经足够了。但在某些情况下，特别是在大量的且读／写比很大的情况下，使用复合同步对象可以在性能上得到很大改进。本文描述了一种算法用以实现这种改进。当然，这不是绝对的，读者可以在实际应用中根据具体情况运用上述算法或其它的算法。
作者简介：冯美霞　主要从事计算机管理信息研究。针对这个问题，考虑是否可动态创建数据管道，这样，每选择一个表就生成一个数据管道既方便又省力，使数据转化在动态环境下完成，增强了通用性