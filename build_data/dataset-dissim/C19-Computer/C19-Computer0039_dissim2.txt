计算机应用
Computer Applications
1999年 第19卷 第7期  Vol.19 No.7 1999



中间件及其在三层客户机/服务器模型中的应用*
宋晓梁　刘东生　许满武
　　摘　要　本文介绍了中间件的五种类型及其各自的特点，并讨论了中间件在三层的客户机/服务器模型中应用的一个实例。
　　关键词　中间件，客户机/服务器模型
　　
MIDDLEWARE AND ITS APPLICATION 
IN A THREE TIER C/S MODEL

Song Xiaoliang　Liu Dongsheng　Xu Manwu
Computer Science and Technology Department, 
National Key Laboratory for Computer Software, Nanjing University, Jiangsu*Nanjing 210093

　　Abstract　In this paper,we discuss the five kinds of the middleware and give a sample of the 
middleware′s application in a three tier C/S model.
　　Keywords　Middleware，Client/server model

　　随着以网络计算为中心的应用系统规模的扩大和软硬件结构的日趋复杂多样，客户端和服务器端的负担也日益繁重，并且传统软件的移植性、互操作性和重用性也都不能满足现在的性能需求，为此人们提出了一种介于客户端和服务器端的软件――中间件。
　　中间件(Middleware)作为前端客户机和后端服务器之间的一个中间层，为应用程序处理提供了如下功能，它一般包含应用逻辑，负责接收客户端的应用请求，对请求做出响应处理后将请求交给后端服务器，并负责将服务器的处理结果返回给客户端。
　　从概念上讲，很早就已经有了中间件的雏形，在主机环境下的TP Monitor就是一种中间件。但是，只有客户机/服务器以及downsizing的概念提出之后，中间件的概念才被人们广泛地关注。在客户机/服务器环境下，一般将中间件放在位于客户机和服务器之间的中间层，负责应用逻辑的处理，从而使客户端变得精干。与此同时，中间件还可以放在客户机和服务器之间的多层应用服务器中。中间件已经成为了联结分布式计算环境中各个相对独立的系统的胶合剂。
　　中间件具有如下特点：
　　易于集成　中间件能无缝地连入应用开发环境中，应用程序可以很容易地定位和共享中间件提供的应用逻辑和数据。
　　易于移植　中间件使与平台有关的细节对于应用程序来说是透明的，因此可以在不改变应用程序代码的情况下改换计算机底层硬件、操作系统或通信协议。
　　易于演进　中间件实现的功能对应用程序来说是透明的，所以可以对局部进行改进而不会影响到系统的其它部分。
　　高可靠性　中间件应该是可靠的，需要提供接管和恢复功能，保证事务及关键性业务不被丢失。
　　易于使用　中间件能和同构或异构环境下的多种数据源通信，同时它能管理数据间的公共逻辑约束。它将用户从复杂的平台、网络、数据库选择中解放出来。
1　中间件的分类
　　根据中间件所起的作用及采用的技术，我们大致可将其分为以下五种。
1.1　基于数据库的中间件
　　基于数据库的中间件是所有中间件中最普遍、最成熟的一种。为了实施测试，还需要描述界面类对象的实例化及生存周期的状态变化过程。它提供了一系列应用程序接口API，通过中间层而不考虑操作系统及网络来访问数据库。并且在很多情况下，API被隐藏在开发工具之中而不被开发者了解。
　　ODBC、JDBC都是基于数据库的中间件标准。通过ODBC访问数据库的方式是绝大多数应用程序使用数据库的方式，它通过使用驱动程序(driver)来提供数据库的独立性，驱动程序与具体的数据库有关，它是一个用以支持ODBC函数调用的模块(通常是一个DLL)，应用程序通过调用驱动程序所支持的函数来操作数据库，若想使应用程序操作不同类型的数据库，就要动态地链接到不同的驱动程序上。测试执行系统的结构如图2所示。JDBC定义了一个Java开发的CLI。JDBC实际上就是一系列用于特定数据库的Java类库，它源于ODBC体系结构。
　　ODBC的结构图如下：　


图1　ODBC结构图
　　现在，Microsoft又提出了OLE-DB。OLE-DB提供了不同数据源的统一的访问点。OLE-DB的目标是提供通过OLE Automation来访问多种数据库，或在应用程序和数据库之间提供一个COM层，通过COM层的对象访问数据库。
　　目前,测试建模技术对建立可控制性和可观察性缺乏支持;在如何支持集成和系统测试等方面缺乏研究[1][5]。目前，很多数据库前端开发工具都支持应用分割技术。
　　但是，在基于数据库的中间件模型中，数据库作为信息的中心存储单元，中间件负责数据间的同步及点到点通信。这种方式不适合于高性能应用处理，因为它需要大量的数据通信，同时，当网络发生故障时，系统将不能正常工作。但在实际的应用系统中，消息生成和传递过程非常复杂，在状态建模中，只需在测试空间内模拟它们的等价效果。当使用RPC时，只需要编写很少的网络程序代码，大部分代码由IDL(Interface Define Language)生成。
　　RPC应用不仅可以调用在远方节点上的子程序，甚至可以在不同操作系统环境下运行。它使程序员不必考虑网络的细节，仍可采用自己熟悉的Call/Return语法。
　　RPC一般采用Call/Return模式，多用于应用程序之间的通信，而且采用同步方式。RPC程序之间的同步通信一般采用Request-Wait-Reply方式， 因此，对小型简单的不需要采用异步通信方式的应用比较适合，但对大型复杂的应用不太适合，因为它需要程序员考虑网络或系统的故障、处理多个网络连接、可移植性、缓冲及流量控制和进程之间的同步等多种问题。
1.3　基于TP Monitor 的中间件
　　TP Monitor是一种复杂的中间件产品，它为应用处理提供了一种通信机制，它允许开发者在TP Monitor环境中定义事务服务。
　　进入状态是一个瞬态，表示对象创建的初始状态。客户通过Transaction RPC(TRPC)机制在TP Monitor中调用事务，TP Monitor运行事务来连接数据库，并将处理结果返回给客户端。TP Monitor提供一系列服务，如应用管理、管理控制和应用之间消息传递等。常见的属性包括全局事务协调、分布式两阶段提交、资源管理器支持、协调故障恢复、高可用性、安全性、网络负载平衡等。
　　在TP Monitor中，事务有一个明确的起止点，如果事务失败，TP Monitor可以回滚事务，不会使系统处于不完整、不一致状态。TP Monitor同时可以复用数据库请求。
　　进入状态是一个瞬态，表示对象创建的初始状态。并且TP Monitor还可以在同一个事务中读写异构数据库中的信息，并保持异构数据库的完整性。
　　常见的TP产品有：BEA的Tuxedo、IBM的CICS、NCR的TopEnd、Microsoft的MTS等。
1.4　基于ORB(Object Request Broker)的中间件
　　基于ORB的中间件主要是采用面向对象的技术，ORB可以看作是与编程语言无关的面向对象的RPC应用。它的成员函数可以采用类似Object-function()方式调用远端的对象。目前，ORB存在两个彼此竞争的标准：CORBA ORB和DCOM ORB。
　　当使用ORB时，IDL(Interface Define Language)用于定义对象之间的接口，它类似于RPC中的IDL定义过程的接口。ORB特别适用于对象接口变化不频繁，不会导致代码经常被重新编译及链接的情况。ORB的总体框架图如图2所示。



图2　ORB的总体框架图
　　理想的要求是，一个ORB应赋予每个对象(与其它对象特别是远程的对象进行通信时)以下的分布透明性：
　　位置：无论其它对象是否处于同一个计算机中；
　　访问路径：与其它对象交换消息经过的途径；
　　重定位：其它对象从一台计算机移至另一台；
　　数据表示：其它对象相应的数据格式；
　　通信机制：使用何种进程间的通信机制和规程；
　　调用机制：其它对象的方法是如何执行的。界面类对象交互状态模型用下面定义的OSN(Object State Net，本文称为子网)表示。对于模拟系统中当前活动的子网，其每个位置是一个检查点，在每个检查点上，可以由测试脚本定义所需的检查，由模拟执行器实施相应的检查。
1.5　基于消息的中间件MOM
　　基于消息的中间件MOM提供了一个完整的处理环境，允许开发者及用户连接不同系统之间的数据和代码，或采用一致的界面进行应用处理的互连。
5　相关工作
　　基于以上技术，实现了一个支持具有图形界面的面向对象软件测试的原型系统JB-OOTE。MOM产品的工作主要是通过将信息以消息的方式在程序间传递来完成。
　　MOM一般可以分为两种形式：消息传递(Message Passing)和消息队列(Message Queuing)。当应用系统执行时，系统的用户与窗口进行交互，导致系统环境产生并传递相应的用户交互消息，由应用系统的界面类对象进行处理。
　　界面类对象生存周期状态转换图和交互状态转换图体现了界面类对象区别于非界面类对象的一些重要特性:
　　・容易确定各个用户交互类型及对应状态；
　　・用户交互导致了界面类对象的状态转换，通过模拟用户交互，可以驱动界面类对象(可控制性)。采用该方式，应用程序既可以订购，也可以广播。该通信模型提供了位置透明性。程序只需要简单地将消息以主题方式发送出去，由中间件来负责将消息传递给所有订购该主题的程序。MOM主要通过agents技术来实现Publish-Subscribe方式应用。
　　(2)　对一个OSN，首先给出一个初始位置p0，表示在此状态时对象准备响应消息。
　　(3)　确定子网之间的消息关联对一个OSN，考察所有已标识的变迁。
　　状态转换图是描述行为模型的常用工具。
　　消息队列方式允许程序无需直接建立起连接即可发送和接收消息。在任何时刻，子网的当前标识M={p}，p∈P，表示对应的界面类对象正处于该p表示的交互状态。消息队列采用异步方式，为信息提供了一个安全的存储方式，特别适用于不是直接连接的应用，如移动用户、发送方或接收方进程可能处于不活动状态的应用。它的缺点是需要一些配置工作，性能不是很高，而且如果队列丢失，整个系统将受到影响。
　　MOM可以克服基于RPC的中间件的限制，提供基于消息的异步通信机制，因此MOM API调用不会阻塞应用程序，同时MOM不会占用大量的网络带宽，可以跟踪事务，通过将事务存储在磁盘上，可以恢复系统及网络故障。
　　常见的MOM产品有：DEC的MessageQ、IBM的MQSeries、Microsoft的MSMQ。
2　中间件优点及具体应用
　　传统的客户机/服务器模式是一种双层模型。双层模型的物理实现方式为：一台桌面电脑当做客户机使用，而一台网络服务器则用于容纳后端数据库引擎。在双层模型里，程序逻辑在客户机与服务器这两种物理位置之间分担，应用程序的商业逻辑必须物理性地驻留于客户机端，或在后端DBMS里以触发器或存储过程的形式实现。为此，考察界面类对象的行为，通过界面类对象来看应用系统的行为，据此实现应用系统的测试。但是它也存在着很多的不利因素。尽管数据访问得到了简化，但却缺乏灵活性，我们通常无法对自己与数据源的交互作用进行完全的控制，因为这种控制是自动的。
　　一个界面类对象处于活动状态时，可以响应用户交互消息和界面类对象消息。
　　双层客户机/服务器模型存在以下三个方面的限制因素：
　　不可伸缩　双层模型无法超越客户机的物理界限，而且服务器也会禁止这种模型的伸缩。
　　不能管理　由于不能封装商业规则，也不能对这些规则进行集中配置，所以常用程序的重用也不方便。
　　性能较差　因为将图形界面与数据源绑定在一起，所以会消耗客户机的主要系统资源。
　　界面类对象的状态转换规则可以用子网的运行规则表示，包括如下几个规则：
　　(1)　触发规则 对p∈*t，子网的变迁t在标识M=*t下是可触发的。
　　正是由于双层客户机/服务器方案存在诸多限制，所以又提出了一种新的三层服务器模型。三层客户机/服务器模型以构建分割式应用程序为基础。对一个应用程序进行分割以后，可将代码划分为不同的逻辑组件，在三层的客户机服务器模型中，这些逻辑组件分为三个逻辑层：用户服务、业务服务和数据服务，它们共同组成一个应用程序。我们把这种三层的设计模型称为“服务模型”。界面类对象交互状态模型用下面定义的OSN(Object State Net，本文称为子网)表示。　　


图3　服务模型结构图
　　使用服务模型，可以把应用程序的需求分解成明确定义的服务。在定义了服务之后，需要进一步创建具体的物理构件来实现它们。构件是一个或几个服务在物理上的封装，可以通过构件的接口获得这些服务。构件可以是.exe或.dll文件、数据库触发器和存储过程的集合，或者任何几个其它物理软件实体。构件是由它所提供的服务以及它和其它构件的相互作用来定义的。然后分析界面类的方法，如果其处理过程包含交互状态，则按如下方法在该子网中生成若干相关的变迁和位置：
　　・标识变迁t∈T。这些构件总是通用的，并且遵守公开的接口标准，所以它们可以被重用，并能被多个应用程序所共享，外界所能知道的就是它们的接口。实际上这些物理构件就是基于ORB的中间件。
　　这种基于构件的三层客户机/服务器的优点可概括为以下四个方面：
　　可重用性　许多应用程序可共享和重用封装在构件中的功能。
　　被测对象控制和观察机制的建立：
　　・由模拟执行器、控制器和插装代码实现对界面类对象的动态模拟和跟踪；
　　・利用交互驱动器产生交互事件，控制被测对象的运行；
　　・在界面类对象交互状态模型中，用等待用户交互的阶段定义对象状态，在对象等待交互时刻，模拟执行器与被测对象之间可以进行数据交换。
　　可管理性　将大型复杂的工程细分为简单、安全的构件工程。
　　易维护性　将业务逻辑部署在中央服务器上，而不是分散在用户桌面上，这有助于处理各种变化，并缩短解决方案的往返时间。
　　在某电视台资料管理及业务处理信息系统中，我们采用了上述三层的服务模型：在客户机上的客户服务程序，在构件服务器上的业务服务程序和在数据服务器上的数据服务程序。
　　定义1 OSN是一个五元组(P，T，F，p0，M0)，它满足如下条件：
　　(1)　P 是有限位置集；
　　(2)　T 是有限变迁集；
　　(3)　p0∈P，M0={p0}是初始标识，称p0是初始位置；标识是包含一个位置的集合；
　　(4)　OSN没有孤立元素，P≠￠,T≠￠，A≠￠；
　　(5)　Fс(P×T)∪(T×P)是关系集合；
　　(6)　任何位置至少有一个前继和一个后继，即：对p∈P，有*p≠￠，p*≠￠；
　　(7)　任何变迁至少有一个后继，有且仅有一个前继，即：对t∈T，有*t≠￠，t*≠￠，且如果ョp1∈*t，p2∈*t，则p1=p2。业务服务程序主要完成业务规则的控制和对数据库的访问，并且业务服务程序是以构件的形式提供给客户服务程序调用的。
5　相关工作
　　基于以上技术，实现了一个支持具有图形界面的面向对象软件测试的原型系统JB-OOTE。数据服务程序主要就是各种智能数据库所能提供的功能，例如存储过程、存储查询等等。
　　该系统的结构如图4所示。


图4
　　在这个三层客户机/服务器模型中，我们把各种业务规则都封装在各自相应的构件中，这样业务规则的实现和客户使用的图形用户界面的实现就相分离了（在传统的两层客户机/服务器模型中，两者是同时在客户机应用程序中实现的），当一方要进行改变时，只对需改变的一方进行改变。与此同时，在同一层上的构件之间也可以相互调用，这样也增加了代码的可重用性，减少了编程量，而且因为构件也是相互独立的，所以当需求改变时也只需对相应的构件进行改变。
4　界面类对象状态建模步骤
　　采用以下的步骤进行界面类对象状态建模:
　　(1)　识别界面类 在文档和源代码中识别出界面类的集合，每个界面类采用平面化表示，用一个子网OSN表示该界面类的对象的交互状态模型。
　　宋晓梁　硕士研究生。主要研究方向：新型程序语言设计。
　　* 国家高新技术研究发展（863）计划及江苏省自然科学基金资助。
　　作者单位：宋晓梁　刘东生　许满武（南京大学计算机科学与技术系，计算机软件新技术国家重点实验室　江苏．南京210093)
参考文献
［1］　Ron Ben-Natan. CORBA-A guide to common object request broker architecture. McGraw-Hill,1995
［2］　D.Box. Q&A ActiveX/COM.Microsoft Systems Journal,
1997；(3):93-105
［3］　A.Birrel,B.J.Nelson. Implementing Remote Procedure
Calls. ACM Transactions on Computer Systems, 1984;2(1):39-59
［4］　黄　俊,许满武,陆剑锋.中间件LSM及其在物资运输调配系统中的应用.微型计算机，1997；17(增刊2)：78-80
［5］　Cynthia McFall, IBM Corporation. An Object Infrastructure for Internet Middleware IBM on Component Broker. IEEE Internet Computing, 1998;2(2)
［6］　Object Management Group. CORBA 2.1 Update Sheet,
1997，8 
　收稿日期:1999-04-23(修改稿)
