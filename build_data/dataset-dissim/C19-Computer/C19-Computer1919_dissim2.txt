微型机与应用
MICROCOMPUTER & ITS APPLICATIONS
2000　Vol.19　No.6　P.10-12




面向对象程序设计语言C++中的多态性
蓝雯飞
摘要：面向对象程序设计语言C++中多态性的形式、特征及其在程序设计中的应用。
关键词：C++语言 多态性 类 虚函数
　　C++是以C语言为基础，支持数据抽象和面向对象的程序设计语言。C++对C语言的扩充部分汲取了许多著名语言中最优秀的特征，如从Algo168中吸取了操作符重载机制等。由于C++语言具有与C语言一样的高执行效率，并容易被熟悉C语言的软件人员接受，因而很快得以流行。
　　现代控制理论正是为了克服经典控制理论的局限性而在20世纪50、60年代逐步发展起来的。多态性是面向对象系统的重要概念之一，它指的是同样的消息能被发送到父类的对象和它的子类的对象。本文重点讨论多态性在程序设计中的应用。
1  多态性的实现形式
　　从广义上说，多态性是指一段程序能够处理多种类型对象的能力。在C++语言中，这种多态性可以通过强制多态、重载多态、类型参数化多态、包含多态4种形式来实现。类型参数化多态和包含多态统称为一般多态性，用来系统地刻画语义上相关的一组类型。重载多态和强制多态统称为特殊多态性，用来刻画语义上无关联的类型间的关系。
　　包含多态是指通过子类型化，1个程序段既能处理类型T的对象，也能够处理类型T的子类型S的对象，该程序段称为多态程序段。公有继承能够实现子类型。在包含多态中，1个对象可以被看作属于不同的类，其间包含关系的存在意味着公共结构的存在。包含多态在不少语言中存在，如整数类型中的子集构成1个子类型。每一个子类型中的对象可以被用在高一级的类型中，高一级类型中的所有操作可用于下一级的对象。在C++中公有继承关系是一种包含多态，每一个类可以直接公有继承父类或多个父类，如语句class Dpublic P1，public P2{……}；表示类D分别是类P1和类P2的子类型。
　　类型参数化多态是指当1个函数(类)统一地对若干类型参数操作时，这些类型表现出某些公共的语义特性，而该函数(类)就是用来描述该特性的。在类型参数化多态中，1个多态函数(类)必须至少带有1个类型参数，该类型参数确定函数(类)在每次执行时操作数的类型。这种函数(类)也称类属函数(类)。类型参数化多态的应用较广泛，被称为最纯的多态。
　　重载是指用同一个名字命名不同的函数或操作符。函数重载是C++对一般程序设计语言中操作符重载机制的扩充，它可使具有相同或相近含义的函数用相同的名字，只要其参数的个数、次序或类型不一样即可。例如：
　　int min(int x，int y)；　　　　　／／求2个整数的最小数
　　int min(int x，int y，int z)；　／／求3个整数的最小数
　　int min（int n，int a［］)；　　／／求n个整数的最小数
　　当用户要求增加比较2个字符串大小的功能时，只需增加：
char*min(char*，char*)；
而原来如何使用这组函数的逻辑不需改变，min的功能扩充很容易，也就是说维护比较容易，同时也提高了程序的可理解性，“min”表示求最小值的函数。
　　强制是指将一种类型的值转换成另一种类型的值进行的语义操作，从而防止类型错误。这里还有必要指出定性控制同模糊控制的主要区别：①模糊控制基于“黑箱”系统，不需要建立数学模型，其控制规则需要凭经验或算法调整，而定性控制则基于定性模型，控制规则基于人们对系统的定性分析。
　　从总体上来说，一般多态性是真正的多态性；特殊多态性只是表面的多态性。因为重载只允许某一个符号有多种类型，而它所代表的值分别具有不同的、不相兼容的类型。第四，智能控制是一个新兴的研究和应用领域，有着极其诱人的发展前途。相比之下，子类与继承却是真正的多态。类型参数化多态也是一种纯正的多态，同一对象或函数在不同的类型上下文中统一地使用而不需采用隐式类型转换、运行时检测或其它各种限制。该理论最初是由G.N.Saridis提出的。包含多态在程序设计中使用十分频繁。
　　派生类继承基类的所有操作，或者说，基类的操作能被用于操作派生类的对象，当基类的操作不能适应派生类时，派生类需重载基类的操作，见下例中的void circle::showarea()。
　　＃include ＜iostream.h＞
　　class point  ／／屏幕上的点类
 ｛int x，y；
　　　public；
　　　point(int x1，int y1)
　　｛x＝x1；y＝y1；｝
　　　void showarea()
　　｛cout＜＜″Area of point is：″＜＜0.0＜＜endl；｝
　　}；
　　class circle：public point／／圆类
　　｛int radius；
　　　public：
　　　circle(int x，int y，int r)：point(x，y){ radius＝r；}
　　void showarea()｛cout＜＜″Area of circle is：″＜＜3.14
　　　*radius*radius＜＜endl；}
　　}；
　　void disparea(const point*p) ／／多态程序段
　　｛p－＞showarea()；｝
　　void main()
　　｛circle c1(1，1，1)；disparea(＆c1)；
　　｝
　　程序的运行结果为0.0(正确结果应为3.14)，出错的原因是：表达式p－＞showarea()中的函数调用在编译时被束定到函数体上，使得这个表达式中的函数调用执行point类的showarea()。为此，当程序员在实现一个派生类而变动了基类中的操作实现时，C++提供的虚函数机制可将这种变动告诉编译器，即将关键字virtual放在类point中该函数的函数说明之前(virtual void showarea())，程序其它部分保持不变(circle：：showarea()自动地成为虚函数)，编译器就不会对函数调用p－＞showarea()进行静态束定(在编译／连接时进行的束定)而产生有关的代码，使函数调用与它所应执行的代码的束定工作在程序运行时进行，这样上述程序的运行结果即为3.14。在程序运行时进行的束定被称为动态束定。
　　利用虚函数，可在基类和派生类中使用相同的函数名定义函数的不同实现，从而实现“一个接口，多种方式”。当用基类指针或引用对虚函数进行访问时，软件系统将根据运行时指针或引用所指向或引用的实际对象来确定调用对象所在类的虚函数版本。
　　C++语言还增加了纯的虚函数机制用来更好地设计包含多态性。对于如图1(a)所示结构的类层次，假如每个类中都有一个函数“void display(void)；”，那么，怎样对它们按多态性进行统一处理呢？如果描述该线性系统的微分方程的系数是常数，则称为线性定常系统。所谓线性控制系统是指系统中各组成环节或元件的状态或特性可以用线性微分方程描述的控制系统。

图1  多态性结构层次
　　为了保证在类A中设置的display()函数是抽象动作，并能说明类A是一个抽象的类，在C++中，可用纯的虚函数语言机制在类A中声明1个成员函数“virtual void display(void)＝0；”。请注意，在类A的子孙类中要么给出display()的定义，要么重新将该函数声明为纯的。定性推理的对象是现实世界的物理系统，例如机器装置或电子器件。
2.2 类型参数化多态
　　参数化多态又称非受限类属多态，即将类型作为函数或类的参数，避免了为各种不同的数据类型编写不同的函数或类，减轻了设计者负担，提高了程序设计的灵活性。神经网络的这些特点表明它有着传递函数在线性系统中的作用，但能够自然地扩展到具有非线性、时变性、复杂性、不确定性的大系统中。
　　将定性推理应用到控制领域，便形成了智能控制的又一个新的分支，即定性控制。定性控制器根据系统的不完全的知识，对系统的输出行为做出预测和控制，这是常规控制器所无法完成的。下面是一个通用数组类模板的定义。
　　template ＜class T，int N＞
　　class array
　　｛T elem［N］；
　　　public：
　　　array()｛for(int   j＝0；j＜N；j++)elem［j］＝0；｝
　　　T＆ operator［］(int index)｛return elem［index］；｝
　　void modi(int index，T value)｛elem［index］＝value；｝
　　｝；
　　其中，T是类型参数，N是常量参数。首先，一般的专家系统中操作人员是系统的组成部分，通过人机对话完成“计算机专家”的功能，而专家控制系统中没有操作人员的参与，要求专家控制系统能够独立和自动地对控制对象做出决策；其次，专家系统通常以离线方式工作，而专家控制系统需要获取在线动态信息，并对系统进行实时控制。由于他们卓越的工作，从而奠定了经典控制理论的基础。在类模板定义中，可在程序中通常使用类型指定的任何地方使用类型参数，可在通常使用特定类型常量表达式的任何地方使用常量参数。
　　成员函数模板可放在类模板中定义，也可放在类外定义，例如：
　　template ＜class T，int N＞
　　T＆ array＜T，N＞：：operator［］(int   index)｛return elem［index］；｝
　　当由类模板生成一个特定的类时，必须指定参数所代表的类型(值)。例如，1个元素类型为int、长度为100的数组类使用类型表达式array＜int，100＞来表示，这个类型表达式被用于说明数组类对象。例如：
　　array＜int，100＞ a： ／／生成特定类的对象a
　　a.modi(1，34)；　　　／／对象a访问成员函数
　　类模板一旦生成了对象和指定了参数表中的类型，编译器在以后访问数据成员和调用成员函数时完全强制为这些类型。
　　在C++中可以重载定义多个同名的函数模板，也可以将1个函数模板与1个同名函数进行重载定义。例如：
　　template ＜class T＞ T min(T a，T b)｛return a＜bta：b；｝
　　template ＜class T＞
　　T min(T a，T b，T c)｛T x＝min(a，b)；return min(x，c)；｝
　　int min(int a，int b)［return a＜bta：b；｝
　　调用min(3，7)，则调用第3个函数；调用min(3.8.5.9)，编译器将根据带2个参数的模板生成新函数min(double，double)；调用min(4，90，76)，则编译器根据带3个参数的模板生成新函数min(int，int，int)；而调用min(56.3，48，71)，编译将给出错误信息，说明无法从上面的模板中生成函数min(double，double，double)，因为编译器在类型推导时，不存在类型强制。
　　模板描述了1组函数或1组类，它主要用于避免程序员进行重复的编码工作，大大简化、方便了面向对象的程序设计。
2.3 重载多态
　　重载是多态性的最简形式，而且把更大的灵活性和扩展性添加到程序设计语言中，它分成操作符重载和函数重载。
　　C++允许为类重定义已有操作符的语义，使系统预定义的操作符可操作类对象。C++语言的一个非常有说服力的例子是count对象的插入操作(＜＜)。由于其类中定义了对位左移操作符“＜＜”进行重载的函数，使C++的输出可按同一种方式进行，学习起来非常容易。并且，增加一个使其能输出复数类的功能(扩充)也很简单，不必破坏原输出逻辑。
关键词：自动控制理论  人工智能  智能控制
　　自动控制理论是自动控制科学的核心。用友员重载操作符的函数也称操作符函数，它与用成员函数重载操作符的函数不同，后者本身是类中成员函数，而它是类的友员函数，是独立于类的一般函数。注意重载操作符时，不能改变它们的优先级，不能改变这些操作符所需操作数的个数。
　　重定义已有的函数称为函数重载。经典控制理论(本质上是频域方法)和现代控制理论(本质上是时域方法)都是建立在控制对象精确模型上的控制理论，而实际上的工业生产系统中的控制对象和过程大多具有非线性、时变性、变结构、不确定性、多层次、多因素等特点，难以建立精确的数学模型。如对构造函数进行重载定义，可使程序有几种不同的途径对类对象进行初始化。1986年，Clocksin和Morgan发表了“Qualitative Control”论文，第一次给出了定性控制的要领，提出了几种控制方案并将其同常规的控制方法做了比较，随后出现了一系列有关定性控制的文章。
2.4 强制多态
　　强制也称类型转换。C++语言定义了基本数据类型之间的转换规则，即：
　　char－＞short－＞int－＞unsigned－＞long－＞unsigned long－＞float－＞double－＞long double
　　赋值操作是个特例，上述原则不再适用。当赋值操作符的右操作数的类型与左操作数的类型不同时，右操作数的值被转换为左操作数的类型的值，然后将转换后的值赋值给左操作数。
　　程序员可以在表达式中使用3种强制类型转换表达式：①static＿cast＜T＞(E)；②T(E)；③(T)E。其中任意一种都可改变编译器所使用的规则，以便按自己的意愿进行所需的类型强制。之后我们还指出，各种控制理论都有其优点、缺点和适用范围，如果能够取长补短，则必然能够扩大其应用的范围，因而是控制理论的发展方向。第三种表达形式是C语言中所使用的风格，在C++中，建议不要再使用这种形式，应选择使用第一种形式。例如，设对象f的类型为double，且其值为3.14。这里还有必要指出定性控制同模糊控制的主要区别：①模糊控制基于“黑箱”系统，不需要建立数学模型，其控制规则需要凭经验或算法调整，而定性控制则基于定性模型，控制规则基于人们对系统的定性分析。
　　通过构造函数进行类类型与其它数据类型之间的转换必须有一个前提，那就是此类一定要有一个只带1个非缺省参数的构造函数，通过构造函数进行类类型的转换只能从参数类型向类类型转换，而想将一个类类型向其它类型转换是办不到的。

图1  反馈控制系统的简化原理框图
　　经典控制理论主要研究线性定常系统。转换函数的设计有以下几点要特别注意：①转换函数必须是类的成员函数；②转换函数不可以指定其返回值类型；③转换函数其参数行不可以有任何参数。
　　强制使类型检查复杂化，尤其在允许重载的情况下，导致无法消解的二义性，在程序设计时要注意避免由于强制带来的二义性。
蓝雯飞（武汉中南民族学院计算机科学系　430074）
参考文献
1，蓝雯飞．C++中的多态性及其应用．计算机时代，1998；（7）
2，蓝雯飞．C++程序设计中的模板技术．计算机时代，1999；（2）
3，蓝雯飞．用C++中的子类型实现软件再用之探讨．计算机 系统应用，1999；（6）
4，肖基毅．面向对象程序设计中的多态性研究．微计算机应 用，1999；20（3）
5，王斌君，葛玮，王靖亚．C++语言与软件的多态性．计算 机工程与应用，1998；34（10）
收稿日期：1999－12－20
