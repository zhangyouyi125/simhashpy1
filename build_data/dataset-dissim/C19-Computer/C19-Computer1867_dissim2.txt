微型机与应用
MICROCOMPUTER & ITS APPLICATIONS
2000 Vol.19 No.3 P.38-40



JavaBeans组件模型的分布式扩展机制
刘启文　傅韶勇　杨利
　　摘　要：结合JavaBeans技术和Java RMI技术提出了JavaBeans组件模型的分布式扩展机制,并在此基础上实现了基于JavaBeans的组件化分布式应用运行平台。
　　关键词：Java语言 JavaBeans组件模型 JavaRMI分布式处理
　　随着软件的规模逐渐庞大化,软件的可靠性、维护性等问题深深困扰着软件开发人员和用户。而且对于企业级应用而言,由于企业业务处于经常的变动之中,目前的应用软件较难快速适应这种改变。
　　组件技术为整个软件行业带来了新的生命力,组件的可重用性、可管理性和可替代性大大改善了软件本身的结构特征,能够有效地解决软件规模日益庞大所带来的种种问题。针对当前企业级应用的特点,开发了基于JavaBeans组件模型的组件化分布式应用运行平台,为企业系统管理提供了一个灵活的、可扩展的、集成的分布式组件框架。在此平台之上,应用系统中的各功能组件根据商业规则的驱动在分布式计算环境中动态地组合起来,并具有组件动态升级和组件之间的动态业务重组等关键特性,支持企业业务变化需求驱动下的系统快速重组和进化。基本步骤如下:
　　1.从其它的节点收集参考时间值;
　　2.考虑影响因素进而估算其时间估计值;
　　3.运用一收敛函数计算这些时间估计值,并获得一正确时间值;
　　4.根据正确时间值来修正各自的时间。CADRE系统（Component-based Application Development & Runtime Environment）支持软件从设计、开发、分发、运行直至管理的各个阶段,整体分为3大部分:组件库管理系统CLMS、基于组件的分布式应用图形化建模工具ArchDesigner和组件化分布式应用运行平台CLAS。
　　组件化分布式应用运行平台是ArchDesigner开发环境基于的目标运行平台,其中该平台最重要的特征是支持了事件驱动的软件体系结构风格以及“业务逻辑与功能实现相分离”的思想。
　　由于各方面的原因,我们对于所提出的将时间同步化从应用层拉至传输层上进行的方法没有得到实验的证实,但是通过上面分析可以预知,与原来的信息传递方式相比,此方法可以大大地改善系统的延迟现象。
　　在一般的软件开发模式下,系统业务逻辑都是硬编码,并被分割在系统的具体功能实现代码之中,运行时刻系统业务逻辑不可发现,系统在业务变化需求下无法实现动态升级。将业务逻辑从功能实现中分离出来,各功能组件独立存在,通过业务逻辑中所提供的接口拼装在一起,形成完整的系统。系统运行时刻,各功能组件通过各自的接口根据业务逻辑的描述进行交互,因此,各组件不依赖其它组件而存在,而且能够非常方便地被其它具有相同接口的组件所替换。
　　由于本平台是分布式计算环境下的组件化应用平台,企业业务逻辑装载在服务器端由规则虚拟机解释执行,功能组件分布在各客户端运行,通过分布式对象总线与服务器端的业务逻辑中的相应接口实现动态联编,各组件通过各自的接口在分布式对象总线上实现透明地互通信和互操作。而且,服务器作为本系统的控制中心需要管理整个分布式网络环境中的所有JavaBeans组件,包括组件监控、配置、访问控制和组件升级等,这些功能保证了整个企业应用具有良好的可管理性。
　　针对以上的系统功能需求,平台中的组件载体必须支持事件在分布式范围内的传播,以触发分布式环境中其它组件的相应动作,而且组件能够提供远程调用接口,使得服务器能够进行统一的、有序的、合理的管理,这样可以使系统中所有组件都运行在1个虚拟的统一地址空间中。由于JavaBeans是局限于单个Java虚拟机地址空间的组件模型,不具有分布式处理的能力,这就要求我们在不修改JavaBeans标准组件模型的前提下对其进行外部扩展,使之能适合分布式应用的需要。
2 组件模型分布式扩展的实现
2.1 分布式扩展方案
　　JavaBeans组件模型基本上是一个静态模型,它的基本思想是通过对程序的标准封装来实现可视化使用,从而快速构造应用。每个JavaBeans都附带了标准而且详细的说明类（BeanInfo）,描述了整个组件所有可暴露的属性、方法和事件,因此,组件框架能够正确地得到这些接口信息,并依此有效地管理和操纵组件。此外,JavaBeans独特的事件监听模型使得不同组件可以动态、灵活地组装起来,组件之间的耦合度得到大大降低。
　　但是,JavaBeans模型在2个方面无法适应本平台分布式应用的需求:①JavaBeans事件模型是在单个虚拟机地址空间中实现组件之间的同步交互操作,对于其它支持事件的组件模型也同样如此（如ActiveX）;②JavaBeans规范并不要求具有分布式对象的特征,JavaBeans组件仅能在本地地址空间被调用,除非该组件同时实现为1个分布式对象,但这又限制了JavaBeans组件的通用性和标准性。
1.3 收敛函数式时间同步化策略
　　收敛函数式时间同步化策略是分布式容错时间同步算法研究中第3种被广泛使用的一种策略。
　　2.各个JavaBeans组件运行在各自JVM的组件容器之中,各组件容器实现为所管理组件的监听器,能够捕获所有组件的事件,并负责将其发布在分布式范围之内。
　　3.脚本语言支持组件的事件监听器注册语法,能够将不同地址空间的组件按照事件监听关系在分布式环境中组装起来。
　　4.业务逻辑管理着系统中所有组件的逻辑句柄,并使用逻辑句柄通过各地的组件容器操作实际的组件实例。
　　5.事件的网络发布以及组件的远程操作都使用JavaRMI分布式对象技术实现,保证事件对象和方法调用参数通过分布式对象技术被正确地在分布式环境中传递,由于服务器端和客户端在交互中都具有主动性,双方都需实现为远程对象,供对方主动传送数据。
2.2 分布式扩展实现
　　在本系统,各分布结点在某一时刻代表着特定的用户身份,组件容器通过组件名和组件实例编号管理运行在该容器中的所有组件的实际句柄,并向其它分布结点提供名字服务,其它结点能够远程地访问容器中的任意组件。这类系统无法容许任何的错误产生。
　　根据ISO所制定的ISO网络参考模型七层结构,SNTP系统属于应用层（application layer）间的网络通信,而TCP/IP是属于传输层（transport layer）的网络通信协定,我们认为造成网络传输时间延迟过大的最主要原因在于TCP/IP通信协定的通信协定延迟（Protocol delay）,造成Δmax估计值过大,如同在传输速度很慢的通信网络上进行时间同步化一样,互相传递交换的时间信息延迟自然变大,间接影响时间同步化的精度。
　　1.方法调用。方法调用的语法形式为BeanHandle.<方法名>（<参数列表>）,规则虚拟机在解释运行该语句时,通过BeanHandle中的用户名确定该组件所在的客户端,得到该客户端的远程对象句柄,通过该远程对象将组件名、组件实例编号、方法名、参数列表发送到客户端,组件容器的名字服务由此查找到实际组件的实例句柄,最后使用Reflection API动态启动对组件的实际操作,方法如下:
　　public boolean InvokeMethod（<组件逻辑句柄>,<方法名>,<参数列表>）;
　　另外,组件实例创建的语法如下:
　　<组件名>BeanInstance=new<组件名>（<用户名>,<参数列表>）;
　　由于服务器端管理着整个系统的所有组件逻辑句柄,该操作能够为新的组件实例生成1个实例编号,与用户名、组件名形成唯一的组件逻辑句柄,最后该信息远程传输到相应客户端进行实际组件实例的创建。
　　2.事件的包装和发送。事件的包装在客户端进行。我们的SNTP系统是采用TCP/IP通信协议来作为网络通信的基础,虽然可以保证时间信息不遗失的重送（retransmission）机制,但增加了网络传输的时间延迟,造成Δmax过大,影响时间同步化结果的精度。组件容器在装载运行1个组件时,解析该组件并为该组件动态地创建1个临时事件监听器。该临时监听器捕获到组件事件后,对事件作如下包装:
　　<用户名,组件名,组件实例编号,事件对象,监听器名称,触发监听器方法名称>,使用服务器端的远程对象将包装后的事件通过RMI转发到服务器,业务逻辑于是触发该组件的所有监听器,下面给出了具体操作。
　　3.事件监听器的注册和注销。在业务逻辑语法中,事件监听器的语法与在Java语言中完全相同,如目前存在组件EventSource和其监听器Listener,则其注册和注销方法如下:
　　EventSourceHandle.add<XXX>Listener（ListenerHandle）;
　　EventSourceHandle.remove<XXX>Listener（ListenerHandle）;
　　规则虚拟机在解释这2个语句时,组件之间的事件监听关系将存储在1个监听表之中,监听表的内容包括:
　　<事件源逻辑句柄,监听器逻辑句柄,监听器类型名称>
　　当客户端经包装后的事件转发到服务器后,服务器将其解包,按照事件源逻辑句柄和监听器名称查找监听表,获得所有的监听器组件后,根据包装事件中的触发监听器方法名和事件对象远程操作实际组件,等价方法如下:
　　ListenerHandle.<监听器方法名称> （<事件对象>）;
2.3 分布式组件框架
　　基于扩展后的JavaBeans组件模型,相应地实现了在平台中的分布式组件框架。图1所示为整个平台的系统结构图,规则引擎是整个应用系统的控制中心,客户代理实现了“零管理”,应用系统的所有功能组件都存储在服务器端,在需要时动态、即时地加载到客户代理端运行。但事实上,在分布式系统中,这些元件都是以相互合作的方式在运作,不可能脱离其它元件而独立,因而这些元件的容错能力决定了分布式系统容错能力,是分布式系统容错主要的研究范畴。
　　根据ISO所制定的ISO网络参考模型七层结构,SNTP系统属于应用层（application layer）间的网络通信,而TCP/IP是属于传输层（transport layer）的网络通信协定,我们认为造成网络传输时间延迟过大的最主要原因在于TCP/IP通信协定的通信协定延迟（Protocol delay）,造成Δmax估计值过大,如同在传输速度很慢的通信网络上进行时间同步化一样,互相传递交换的时间信息延迟自然变大,间接影响时间同步化的精度。
　　图1所示的分布式总线是使用Java RMI技术实现的,该总线支持扩展后JavaBeans组件模型的事件传递、监听器触发以及组件远程调用,整个平台的功能大致可以分为以下5步:

图1 组件化分布式应用运行平台系统结构图
［注］α:事件通道 β:组件操作通道 γ:组件分发通道
　　第一步:客户代理的组件处理器接收远程组件调用操作,并解释执行该调用操作。对于创建组件实例操作,需首先通过γ通道从规则引擎中下载所需的组件（即JAR文件）,并安装在本地。主仆式与时间服务器式时间同步化策略的优点是其原理和设备都很简单,但缺点是容错能力低、集中式管理易受瓶颈效应（bottle-neck effect）影响等。
　　第三步:系统运行过程中,临时事件监听器监听到相应组件的特定事件后,事件监听器将事件包装成标准的扩展事件形式,通过α通道转发给规则引擎。由于我们的SNTP系统主要是针对局域网络应用,根据之前进行程序测量的结果,最终可得局域网络的真正传输时间延迟小于10ms。
　　第五步:规则引擎中的组件处理器得到规则虚拟机解释执行中触发的组件操作信息,包装成组件标准的扩展操作形式,通过β通道传送到指定的客户代理。
　　以上介绍的组件运行平台为企业管理提供了一个开放的、集成的、灵活的、可扩展的分布式计算环境。该平台实现采用了Java、JavaBeans组件模型和JavaRMI分布式对象技术,为使软件组件能够灵活组装在一起进行协同工作,设计了一种类似硬件总线式的软件总线。对于各种共享重用的组件,采用延迟绑定的动态连接方式运行,保证了组件动态、快速升级的特性。我们的SNTP系统是采用TCP/IP通信协议来作为网络通信的基础,虽然可以保证时间信息不遗失的重送（retransmission）机制,但增加了网络传输的时间延迟,造成Δmax过大,影响时间同步化结果的精度。
刘启文（沈阳宝钢东软集团软件中心110006）
傅韶勇（沈阳宝钢东软集团软件中心110006）
杨利（沈阳宝钢东软集团软件中心110006）
参考文献
1，Schmide R.Concepts for Developing Component-Based Systems.International Workshop on Component-Based Software Engineering,1998
2，徐征,刘晓铭,刘积仁.一种构件化的动态软件系统模型.小型微型计算机系统,1992;(2)
3，麦中凡.基于分布式对象的软件构件.计算机科学,1994;24(4)
收稿日期：1999-10-20
