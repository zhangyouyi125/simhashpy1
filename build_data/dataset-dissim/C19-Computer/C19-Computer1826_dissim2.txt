微型机与应用
MICROCOMPUTER & ITS APPLICATIONS
2000 Vol.19 No.2 P.11-12




Sybase多表复杂关联数据的传输
王双成　鲁明羽　陆玉昌
摘 要： 讨论了多表复杂关联数据的传输问题，给出了避免传输错误的有效方法。一般的数值计算程序可以从中知道算法的错误，但对于控制和仿真培训领域，如果控制算法或仿真数学模型运行中出现异常使程序终止运行，就会带来不良后果；而如果用屏蔽异常的方法，当发生溢出时，运算结果由80387设置，在随后的运算中可能产生更严重的异常。在该系统中，各客户端站点需向中央服务器传输多种具有复杂关联的数据表。由于受Sybase数据库数据完整性的制约，如果传输次序不正确，容易造成某些表的整表数据或一些表的部分记录的丢失。下面从数据传输环境、数据组织、数据表排序、数据传输、出错处理5个部分阐述多表复杂关联数据的传输处理过程。
1 数据传输环境
　　国家教委服务器端的网络操作系统采用Windows NT 4.0中文版，而下属各国家重点实验室作为客户端，其操作系统平台为Windows 95／98。
　　数据库管理系统采用的是Sybase 11.5。这是一个开放的对象关系型数据库管理系统，可为用户提供1个高性能、开放的、分布式的、端到端的体系结构，能满足网络中关键任务的专业化应用开发需求。对这些成员函数的实现来说，最大问题是效率，用了定点数后效率大大下降是不能容许的。
2 数据组织
　　如果源数据库和目的数据库是同构的，则可以直接建立数据管道，处理起来比较简单。但在此系统中，国家教委的数据表存放的是所有国家重点实验室的数据，因此源数据库和目的数据库对应的数据表具有不同的结构。
　　1.源数据组织
　　为使源数据库表中的记录传输到目的数据库对应表后具有唯一的标识，采用了下面的处理方法：从基本情况表中抽取实验室代码和分室代码并存入1个辅助表中这个表只存放1个记录；将这一辅助表分别和每一数据表连接，产生对应的视图作为源数据数据包。每个表中要有传输日期字段，其数据靠程序从界面读入，以便既可以传输新数据添加，又可以传输历史数据更新，并可以随时进行数据传输。
　　2.目的数据组织
　　系统采用PB数据管道的更新／添加方式进行数据传输。这种方式是按目的数据库对应表的主码进行检索，如果没有一致的主码就进行添加，若有一致的主码则进行更新。这样就要求在目的数据库的每一个数据表中必须把实验室代码和分室代码加入主码中，即每一个数据表要含有实验室代码和分室代码2个字段并且是表主码的组成部分。
3 数据表排序
　　数据库管理系统所进行的数据完整性检验，主要有单表的数据一致性检验和多表之间的关联一致性检验。这里涉及的表与表之间的关联一致性检验就是对有关联的表进行主码-外码对应性检查。
　　实际测试中，乘法的速度为80387指令的1／5，加法的速度为80387指令的1．5倍，效率能令人满意。1个表的主码可以不与任何表关联，也可以和多个表的对应外码相联，而1个表的1个外码必须且只能和1个表的主码相联。没有主码的数据表可以任意地传输。
　　本文设计的这种高效定点数类，应用于某炼油厂硫磺回收装置仿真培训系统的数学模型开发中，避免了80387的浮点异常，取得了良好的效果。一般的数值计算程序可以从中知道算法的错误，但对于控制和仿真培训领域，如果控制算法或仿真数学模型运行中出现异常使程序终止运行，就会带来不良后果；而如果用屏蔽异常的方法，当发生溢出时，运算结果由80387设置，在随后的运算中可能产生更严重的异常。因此应将表外码设置成不允许为空。
　　数据丢失的另一个主要原因是表传输顺序错误。为了解决这一问题，提出了在传输前对数据表按关联关系进行排序的解决方法。排序过程：
　　第一步，先任意地排序第一类表，即把第一类表排在整体表序列前部；
　　第二步，逐个排序第二类表，任意地取1个第二类数据表如其外码与其它数据表的主码相关联，用PB展示出如图1所示选定数据表的向下关联全图，自底向上排：先考察表1.2.2.1，如果该表没有排过序则按序排上该表，如果该表已排过序就跳过该表；接下来考察表1.2.2，与处理表1.2.2.1的方法相同。同层次的表顺序不限，如表1.2.1和表1.2.2的顺序任意。不同层次的数据表要严格按照自下而上的原则，直至把最上面的根表表1排完为止，再选择第二个第二类表，用同样的方法排序，直到排完所有的第二类数据表，这样就把所有的数据表排了序。

图1　数据表的向下关联全图
　　具体实现时，采用的方法是根据数据表向下关联全图，利用拓朴排序算法编程，自动产生表传输顺序，也允许用户人工制订次序。这里的拓朴排序算法简要描述如下：
　　（1）根据数据表向下关联全图，建立其邻接表存储结构，且在其邻接表的头结点中增加1个存放顶点入度的数据域。邻接表中每个顶点对应图中的1个数据表结点，有1个数据域存放表名； 　　　（2）建立入度为零的顶点链栈S；
　　（3）如S非空，转（4），否则转（6）；
　　（4）将S的栈顶V对应的表名T输出到队列Q；
　　（5）将所有其外码与T的主码相联的数据表的对应顶点入度减1，且减1后如其入度为零则压入S，转（3）；
　　（6）逐个输出队列Q中的诸表名即为所求的数据表传输顺序。但是，临时型实数没有隐藏位，1个格式化的临时型实数中第63位永远为1。
　　有效数字有时被称为尾数。这种方式适用于要求对源数据进行复杂处理且传输的数据量比较小的数据传输问题，非常灵活，几乎可以满足各种需求，只要通过编程即可实现，但编程工作量比较大，而且程序调试困难；另一种是通过PB提供的数据管道来实现。首先要组织好源数据，之后建立数据管道，最后用程序调用数据管道。这种方式实现简单、可靠，而且容易调试，适用于大量的、不需要复杂处理的数据传输，但不如利用程序传输灵活。此二种方法各有利弊，需根据实际情况做出选择。
5 出错处理
　　在传输调试过程中可能出现的错误主要有：
　　（1）一些数据表没有传输过去（原因是表传输顺序错误）；
　　（2）某些表的部分记录没有传输过去（由于数据完整性错误或外码错误）；
　　（3）程序调用错误；
　　（4）管道错误；
　　（5）源数据表和目的数据表的结构不匹配等。在这中间要考虑实数为零的情况，因为零的指数必为0，若指数加了32，就成了伪零［1］，是80387所不支持的，会引起操作异常。定点数的完整定义如下：
class fixed
｛
　 public：
　　　　 union
　　　　｛
　　　　　 ＿int64 i64；
　　　　　　　 structunsigned long low；long high；i32；
　　　　　｝；
　　　　　 ＿fastcall fixed　（）｛i64＝0；｝
　　　　　 ＿fastcall fixed（const fixed ＆f）｛i64＝f．i64；｝
　　　　　 ＿fastcall fixed（long h，unsigned long 1＝0）｛i32．
　　　　　　　　　　　　　　　　　　　　　　 high＝h；i32．low＝1；｝
　　　　 ＿fastcall fixed（long double）；
　　　　　 ＿fastcall operator long double（）const；
　　　　　 fixed ＆＿fastcall operator＝（long double ld）｛fixed 
　　　　　　　　　　　　　　tmp（ld）；i64＝tmp．i64；return *this；｝
　　　　　 fixed＿fastcall operator＋（）const｛return *this；｝
　　　　 fixed＿fastcall operator－（）const｛fixed tmp（*this）；
　　　　　　　　　　　　　　　　　　 tmp．i64＝－i64；return tmp；｝
　　　　　 fixed ＆＿fastcall operator ＋＝（const fixed ＆ f）
　　　　　　　　　　　　　　　　　　　｛i64＋＝f．i64；return *this；｝
　　　　 fixed ＆＿fastcall operator*＝（const fixed ＆ f）
　　　　　　　　　　　　　　　　　　　｛i64－＝f．i64；return *this；｝
　　　　　 fixed ＆＿fastcall operator*＝（const fixed ＆）；
　　　　　 fixed ＆＿fastcall operator ／＝（const fixed ＆）；
　　　　　 fixed＿fastcall operator＋（const fixed ＆ f）const
　　　　　　　 ｛fixed tmp（*this）；tmp．i64＝i64＋f．i64；return
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 tmp；｝ 
　　　　　fixed＿fastcall operator －（const fixed ＆ f）const
　　　　　　　 ｛fixed tmp（*this）；tmp．i64＝i64－f．i64；return
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 tmp；｝


　　在数值运算程序的开发中，希望定点数与浮点数的使用方法完全相同，所以在类中定义了这些运算符重载的成员函数，保证了使用2种数的C代码的一致性。这些方法和措施不仅适用于本课题，而且对类似项目也有一定的借鉴作用。
　　对于定点数和浮点数相互转换的2个函数，本文在3种浮点数中选择long double，即80387中的临时型实数来做相互转换，这样选择的理由是：
　　1．临时型实数的精度最高，不会因转换而丢失精度